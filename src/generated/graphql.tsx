import { gql } from '@apollo/client';
import * as ApolloReactCommon from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ISO8601Date: { input: string; output: string; }
  ISO8601DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
};

export type Booking = {
  __typename?: 'Booking';
  bookingDate: Scalars['ISO8601Date']['output'];
  cancellationReason?: Maybe<Scalars['String']['output']>;
  cancelledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  club: Club;
  clubId: Scalars['ID']['output'];
  confirmationCode: Scalars['String']['output'];
  court: Court;
  courtId: Scalars['ID']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  duration: Scalars['Int']['output'];
  endTime: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  match?: Maybe<Match>;
  paymentMethod?: Maybe<Scalars['String']['output']>;
  paymentStatus: Scalars['String']['output'];
  payments: Array<Payment>;
  player: Player;
  playerId: Scalars['ID']['output'];
  specialInstructions?: Maybe<Scalars['String']['output']>;
  sport: Sport;
  sportId: Scalars['ID']['output'];
  startTime: Scalars['String']['output'];
  status: Scalars['String']['output'];
  totalPrice: Scalars['Float']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type BookingInput = {
  bookingDate: Scalars['ISO8601Date']['input'];
  clubId: Scalars['ID']['input'];
  courtId: Scalars['ID']['input'];
  duration: Scalars['Int']['input'];
  endTime: Scalars['String']['input'];
  paymentMethod?: InputMaybe<Scalars['String']['input']>;
  playerId: Scalars['ID']['input'];
  specialInstructions?: InputMaybe<Scalars['String']['input']>;
  sportId: Scalars['ID']['input'];
  startTime: Scalars['String']['input'];
  totalPrice: Scalars['Float']['input'];
};

/** Autogenerated input type of CancelBooking */
export type CancelBookingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of CancelBooking. */
export type CancelBookingPayload = {
  __typename?: 'CancelBookingPayload';
  booking?: Maybe<Booking>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Club = {
  __typename?: 'Club';
  amenities?: Maybe<Scalars['JSON']['output']>;
  bookings: Array<Booking>;
  city?: Maybe<Scalars['String']['output']>;
  clubSports: Array<ClubSport>;
  country?: Maybe<Scalars['String']['output']>;
  courts: Array<Court>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  district?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  imagesUrls: Array<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  matches: Array<Match>;
  name: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  rating?: Maybe<Scalars['Float']['output']>;
  reviewCount: Scalars['Int']['output'];
  reviews: Array<Review>;
  sports: Array<Sport>;
  status: Scalars['String']['output'];
  streetAddress?: Maybe<Scalars['String']['output']>;
  telegram?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  website?: Maybe<Scalars['String']['output']>;
  workingHours?: Maybe<Scalars['JSON']['output']>;
};

export type ClubSport = {
  __typename?: 'ClubSport';
  available: Scalars['Boolean']['output'];
  club: Club;
  clubId: Scalars['ID']['output'];
  courts: Array<Court>;
  courtsCount: Scalars['Int']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  pricePerHour: Scalars['Float']['output'];
  sport: Sport;
  sportId: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Court = {
  __typename?: 'Court';
  bookings: Array<Booking>;
  club: Club;
  clubId: Scalars['ID']['output'];
  clubSport: ClubSport;
  clubSportId: Scalars['ID']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  indoor: Scalars['Boolean']['output'];
  lighting: Scalars['Boolean']['output'];
  maintenanceNotes?: Maybe<Scalars['String']['output']>;
  matches: Array<Match>;
  name: Scalars['String']['output'];
  status: Scalars['String']['output'];
  surface?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of CreateBooking */
export type CreateBookingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  input: BookingInput;
};

/** Autogenerated return type of CreateBooking. */
export type CreateBookingPayload = {
  __typename?: 'CreateBookingPayload';
  booking?: Maybe<Booking>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateMatch */
export type CreateMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  input: MatchInput;
};

/** Autogenerated return type of CreateMatch. */
export type CreateMatchPayload = {
  __typename?: 'CreateMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  match?: Maybe<Match>;
};

/** Autogenerated input type of CreatePayment */
export type CreatePaymentInput = {
  amount: Scalars['Float']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  payableId: Scalars['ID']['input'];
  payableType: Scalars['String']['input'];
  paymentMethod: Scalars['String']['input'];
  playerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreatePayment. */
export type CreatePaymentPayload = {
  __typename?: 'CreatePaymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  payment?: Maybe<Payment>;
};

/** Autogenerated input type of CreatePlayer */
export type CreatePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  input: PlayerInput;
};

/** Autogenerated return type of CreatePlayer. */
export type CreatePlayerPayload = {
  __typename?: 'CreatePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  player?: Maybe<Player>;
};

/** Autogenerated input type of CreatePost */
export type CreatePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  input: PostInput;
};

/** Autogenerated return type of CreatePost. */
export type CreatePostPayload = {
  __typename?: 'CreatePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  post?: Maybe<Post>;
};

/** Autogenerated input type of CreateReview */
export type CreateReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  rating: Scalars['Int']['input'];
  revieweeId: Scalars['ID']['input'];
  revieweeType: Scalars['String']['input'];
  reviewerId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateReview. */
export type CreateReviewPayload = {
  __typename?: 'CreateReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  review?: Maybe<Review>;
};

/** Autogenerated input type of DeletePost */
export type DeletePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeletePost. */
export type DeletePostPayload = {
  __typename?: 'DeletePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteReview */
export type DeleteReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteReview. */
export type DeleteReviewPayload = {
  __typename?: 'DeleteReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Follow = {
  __typename?: 'Follow';
  createdAt: Scalars['ISO8601DateTime']['output'];
  follower: Player;
  followerId: Scalars['ID']['output'];
  following: Player;
  followingId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of FollowPlayer */
export type FollowPlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  followedId: Scalars['ID']['input'];
  followerId: Scalars['ID']['input'];
};

/** Autogenerated return type of FollowPlayer. */
export type FollowPlayerPayload = {
  __typename?: 'FollowPlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  follow?: Maybe<Follow>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of JoinMatch */
export type JoinMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  matchId: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
  playerId: Scalars['ID']['input'];
};

/** Autogenerated return type of JoinMatch. */
export type JoinMatchPayload = {
  __typename?: 'JoinMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  match?: Maybe<Match>;
  matchParticipant?: Maybe<MatchParticipant>;
};

/** Autogenerated input type of LeaveMatch */
export type LeaveMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  matchId: Scalars['ID']['input'];
  playerId: Scalars['ID']['input'];
};

/** Autogenerated return type of LeaveMatch. */
export type LeaveMatchPayload = {
  __typename?: 'LeaveMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  match?: Maybe<Match>;
  success: Scalars['Boolean']['output'];
};

export type Like = {
  __typename?: 'Like';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  likeable: LikeableUnion;
  likeableId: Scalars['ID']['output'];
  likeableType: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of LikePost */
export type LikePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  playerId: Scalars['ID']['input'];
  postId: Scalars['ID']['input'];
};

/** Autogenerated return type of LikePost. */
export type LikePostPayload = {
  __typename?: 'LikePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  liked: Scalars['Boolean']['output'];
  post?: Maybe<Post>;
};

export type LikeableUnion = Post;

/** Autogenerated input type of LoginPlayer */
export type LoginPlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

/** Autogenerated return type of LoginPlayer. */
export type LoginPlayerPayload = {
  __typename?: 'LoginPlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  player?: Maybe<Player>;
  refreshToken?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of LogoutPlayer */
export type LogoutPlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of LogoutPlayer. */
export type LogoutPlayerPayload = {
  __typename?: 'LogoutPlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Match = {
  __typename?: 'Match';
  booking?: Maybe<Booking>;
  bookingId?: Maybe<Scalars['ID']['output']>;
  cancellationPolicy?: Maybe<Scalars['String']['output']>;
  cancelledAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  club: Club;
  clubId: Scalars['ID']['output'];
  competitive: Scalars['Boolean']['output'];
  court?: Maybe<Court>;
  courtBooked: Scalars['Boolean']['output'];
  courtId?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  duration: Scalars['Int']['output'];
  durationPlayed?: Maybe<Scalars['Int']['output']>;
  finalScore?: Maybe<Scalars['String']['output']>;
  genderPreference?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  levelMax?: Maybe<Scalars['Float']['output']>;
  levelMin?: Maybe<Scalars['Float']['output']>;
  levelName?: Maybe<Scalars['String']['output']>;
  matchDate: Scalars['ISO8601DateTime']['output'];
  matchParticipants: Array<MatchParticipant>;
  matchType?: Maybe<Scalars['String']['output']>;
  organizer: Player;
  organizerId: Scalars['ID']['output'];
  participants: Array<Player>;
  payments: Array<Payment>;
  playersNeeded: Scalars['Int']['output'];
  posts: Array<Post>;
  pricePerPerson?: Maybe<Scalars['Float']['output']>;
  sport: Sport;
  sportId: Scalars['ID']['output'];
  spotsAvailable: Scalars['Int']['output'];
  status: Scalars['String']['output'];
  totalPlayers: Scalars['Int']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  winnerTeam?: Maybe<Scalars['String']['output']>;
};

export type MatchInput = {
  bookingId?: InputMaybe<Scalars['ID']['input']>;
  cancellationPolicy?: InputMaybe<Scalars['String']['input']>;
  clubId: Scalars['ID']['input'];
  competitive?: InputMaybe<Scalars['Boolean']['input']>;
  courtBooked?: InputMaybe<Scalars['Boolean']['input']>;
  courtId?: InputMaybe<Scalars['ID']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  duration: Scalars['Int']['input'];
  genderPreference?: InputMaybe<Scalars['String']['input']>;
  levelMax?: InputMaybe<Scalars['Float']['input']>;
  levelMin?: InputMaybe<Scalars['Float']['input']>;
  levelName?: InputMaybe<Scalars['String']['input']>;
  matchDate: Scalars['ISO8601DateTime']['input'];
  matchType?: InputMaybe<Scalars['String']['input']>;
  organizerId: Scalars['ID']['input'];
  playersNeeded: Scalars['Int']['input'];
  pricePerPerson?: InputMaybe<Scalars['Float']['input']>;
  sportId: Scalars['ID']['input'];
  totalPlayers: Scalars['Int']['input'];
};

export type MatchParticipant = {
  __typename?: 'MatchParticipant';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  joinMessage?: Maybe<Scalars['String']['output']>;
  match: Match;
  matchId: Scalars['ID']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  position?: Maybe<Scalars['Int']['output']>;
  role: Scalars['String']['output'];
  status: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  cancelBooking?: Maybe<CancelBookingPayload>;
  /** Create a new booking */
  createBooking?: Maybe<CreateBookingPayload>;
  /** Create a new match */
  createMatch?: Maybe<CreateMatchPayload>;
  createPayment?: Maybe<CreatePaymentPayload>;
  /** Create a new player */
  createPlayer?: Maybe<CreatePlayerPayload>;
  /** Create a new post */
  createPost?: Maybe<CreatePostPayload>;
  createReview?: Maybe<CreateReviewPayload>;
  deletePost?: Maybe<DeletePostPayload>;
  deleteReview?: Maybe<DeleteReviewPayload>;
  followPlayer?: Maybe<FollowPlayerPayload>;
  /** Join a match */
  joinMatch?: Maybe<JoinMatchPayload>;
  leaveMatch?: Maybe<LeaveMatchPayload>;
  /** Like or unlike a post */
  likePost?: Maybe<LikePostPayload>;
  loginPlayer?: Maybe<LoginPlayerPayload>;
  logoutPlayer?: Maybe<LogoutPlayerPayload>;
  refreshToken?: Maybe<RefreshTokenPayload>;
  refundPayment?: Maybe<RefundPaymentPayload>;
  /** Send a verification code to a phone number via Telegram */
  sendTelegramVerificationCode?: Maybe<SendTelegramVerificationCodePayload>;
  unfollowPlayer?: Maybe<UnfollowPlayerPayload>;
  unlikePost?: Maybe<UnlikePostPayload>;
  updateBooking?: Maybe<UpdateBookingPayload>;
  updateMatch?: Maybe<UpdateMatchPayload>;
  updatePlayer?: Maybe<UpdatePlayerPayload>;
  updatePost?: Maybe<UpdatePostPayload>;
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Verify a Telegram verification code and authenticate user */
  verifyTelegramCode?: Maybe<VerifyTelegramCodePayload>;
};


export type MutationCancelBookingArgs = {
  input: CancelBookingInput;
};


export type MutationCreateBookingArgs = {
  input: CreateBookingInput;
};


export type MutationCreateMatchArgs = {
  input: CreateMatchInput;
};


export type MutationCreatePaymentArgs = {
  input: CreatePaymentInput;
};


export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationCreateReviewArgs = {
  input: CreateReviewInput;
};


export type MutationDeletePostArgs = {
  input: DeletePostInput;
};


export type MutationDeleteReviewArgs = {
  input: DeleteReviewInput;
};


export type MutationFollowPlayerArgs = {
  input: FollowPlayerInput;
};


export type MutationJoinMatchArgs = {
  input: JoinMatchInput;
};


export type MutationLeaveMatchArgs = {
  input: LeaveMatchInput;
};


export type MutationLikePostArgs = {
  input: LikePostInput;
};


export type MutationLoginPlayerArgs = {
  input: LoginPlayerInput;
};


export type MutationLogoutPlayerArgs = {
  input: LogoutPlayerInput;
};


export type MutationRefreshTokenArgs = {
  input: RefreshTokenInput;
};


export type MutationRefundPaymentArgs = {
  input: RefundPaymentInput;
};


export type MutationSendTelegramVerificationCodeArgs = {
  input: SendTelegramVerificationCodeInput;
};


export type MutationUnfollowPlayerArgs = {
  input: UnfollowPlayerInput;
};


export type MutationUnlikePostArgs = {
  input: UnlikePostInput;
};


export type MutationUpdateBookingArgs = {
  input: UpdateBookingInput;
};


export type MutationUpdateMatchArgs = {
  input: UpdateMatchInput;
};


export type MutationUpdatePlayerArgs = {
  input: UpdatePlayerInput;
};


export type MutationUpdatePostArgs = {
  input: UpdatePostInput;
};


export type MutationUpdateReviewArgs = {
  input: UpdateReviewInput;
};


export type MutationVerifyTelegramCodeArgs = {
  input: VerifyTelegramCodeInput;
};

export type NotifiableUnion = Booking | Match | Payment;

export type Notification = {
  __typename?: 'Notification';
  createdAt: Scalars['ISO8601DateTime']['output'];
  data?: Maybe<Scalars['JSON']['output']>;
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  notifiable?: Maybe<NotifiableUnion>;
  notifiableId?: Maybe<Scalars['ID']['output']>;
  notifiableType?: Maybe<Scalars['String']['output']>;
  notificationType: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  priority: Scalars['String']['output'];
  read: Scalars['Boolean']['output'];
  readAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  title: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type PayableUnion = Booking | Match;

export type Payment = {
  __typename?: 'Payment';
  amount: Scalars['Float']['output'];
  completedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  currency: Scalars['String']['output'];
  gatewayResponse?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['ID']['output'];
  payable: PayableUnion;
  payableId: Scalars['ID']['output'];
  payableType: Scalars['String']['output'];
  paymentMethod?: Maybe<Scalars['String']['output']>;
  paymentType: Scalars['String']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  refundAmount?: Maybe<Scalars['Float']['output']>;
  refundReason?: Maybe<Scalars['String']['output']>;
  refundedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  status: Scalars['String']['output'];
  transactionId?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Player = {
  __typename?: 'Player';
  address?: Maybe<Scalars['String']['output']>;
  age?: Maybe<Scalars['Int']['output']>;
  avatarUrl?: Maybe<Scalars['String']['output']>;
  bookings: Array<Booking>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  email: Scalars['String']['output'];
  followers: Array<Player>;
  following: Array<Player>;
  id: Scalars['ID']['output'];
  latitude?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  levelName?: Maybe<Scalars['String']['output']>;
  likes: Array<Like>;
  longitude?: Maybe<Scalars['Float']['output']>;
  matchParticipants: Array<MatchParticipant>;
  name: Scalars['String']['output'];
  notifications: Array<Notification>;
  organizedMatches: Array<Match>;
  payments: Array<Payment>;
  phone?: Maybe<Scalars['String']['output']>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  posts: Array<Post>;
  preferences?: Maybe<Scalars['JSON']['output']>;
  reviews: Array<Review>;
  stats?: Maybe<Scalars['JSON']['output']>;
  status: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type PlayerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  age?: InputMaybe<Scalars['Int']['input']>;
  email: Scalars['String']['input'];
  latitude?: InputMaybe<Scalars['Float']['input']>;
  level?: InputMaybe<Scalars['Float']['input']>;
  levelName?: InputMaybe<Scalars['String']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  preferences?: InputMaybe<Scalars['JSON']['input']>;
  stats?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type Post = {
  __typename?: 'Post';
  content?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  imageUrl?: Maybe<Scalars['String']['output']>;
  likeCount: Scalars['Int']['output'];
  likes: Array<Like>;
  likesCount: Scalars['Int']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  postType: Scalars['String']['output'];
  postable?: Maybe<PostableUnion>;
  postableId?: Maybe<Scalars['ID']['output']>;
  postableType?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  visibility: Scalars['String']['output'];
};

export type PostInput = {
  content?: InputMaybe<Scalars['String']['input']>;
  playerId: Scalars['ID']['input'];
  postType: Scalars['String']['input'];
  postableId?: InputMaybe<Scalars['ID']['input']>;
  postableType?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  visibility: Scalars['String']['input'];
};

export type PostableUnion = Match;

export type Query = {
  __typename?: 'Query';
  /** Get a booking by ID */
  booking?: Maybe<Booking>;
  /** Get all bookings */
  bookings: Array<Booking>;
  /** Get a club by ID */
  club?: Maybe<Club>;
  /** Get available time slots for a club on a specific date */
  clubAvailability: Array<Scalars['String']['output']>;
  /** Get all clubs */
  clubs: Array<Club>;
  /** Get available time slots for a specific court */
  courtAvailability: Array<Scalars['String']['output']>;
  /** Get the currently authenticated player */
  currentPlayer?: Maybe<Player>;
  /** Get the default club */
  defaultClub?: Maybe<Club>;
  /** Generate an image using AI */
  generateImage?: Maybe<Scalars['String']['output']>;
  /** Get a match by ID */
  match?: Maybe<Match>;
  /** Get all matches */
  matches: Array<Match>;
  /** Get notifications for a player */
  notifications: Array<Notification>;
  /** Get a player by ID */
  player?: Maybe<Player>;
  /** Get all players */
  players: Array<Player>;
  /** Get a post by ID */
  post?: Maybe<Post>;
  /** Get all posts */
  posts: Array<Post>;
  /** Search clubs by name, location, or amenities */
  searchClubs: Array<Club>;
  /** Search matches by various criteria */
  searchMatches: Array<Match>;
  /** Search players by name, location, or skill level */
  searchPlayers: Array<Player>;
  /** Get a sport by ID */
  sport?: Maybe<Sport>;
  /** Get all sports */
  sports: Array<Sport>;
};


export type QueryBookingArgs = {
  id: Scalars['ID']['input'];
};


export type QueryBookingsArgs = {
  clubId?: InputMaybe<Scalars['ID']['input']>;
  endDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  playerId?: InputMaybe<Scalars['ID']['input']>;
  startDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};


export type QueryClubArgs = {
  id: Scalars['ID']['input'];
};


export type QueryClubAvailabilityArgs = {
  clubId: Scalars['ID']['input'];
  date: Scalars['ISO8601Date']['input'];
};


export type QueryClubsArgs = {
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  radius?: InputMaybe<Scalars['Float']['input']>;
};


export type QueryCourtAvailabilityArgs = {
  courtId: Scalars['ID']['input'];
  date: Scalars['ISO8601Date']['input'];
};


export type QueryGenerateImageArgs = {
  height?: InputMaybe<Scalars['Int']['input']>;
  prompt: Scalars['String']['input'];
  width?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID']['input'];
};


export type QueryMatchesArgs = {
  endDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  radius?: InputMaybe<Scalars['Float']['input']>;
  startDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  upcoming?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryNotificationsArgs = {
  playerId: Scalars['ID']['input'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPostArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPostsArgs = {
  postType?: InputMaybe<Scalars['String']['input']>;
  visibility?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySearchClubsArgs = {
  amenities?: InputMaybe<Array<Scalars['String']['input']>>;
  location?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySearchMatchesArgs = {
  dateRange?: InputMaybe<Scalars['String']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  skillLevel?: InputMaybe<Scalars['String']['input']>;
  sportId?: InputMaybe<Scalars['ID']['input']>;
};


export type QuerySearchPlayersArgs = {
  availableOnly?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  skillLevel?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySportArgs = {
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RefreshToken */
export type RefreshTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  refreshToken: Scalars['String']['input'];
};

/** Autogenerated return type of RefreshToken. */
export type RefreshTokenPayload = {
  __typename?: 'RefreshTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  refreshToken?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RefundPayment */
export type RefundPaymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  paymentId: Scalars['ID']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
  refundAmount?: InputMaybe<Scalars['Float']['input']>;
};

/** Autogenerated return type of RefundPayment. */
export type RefundPaymentPayload = {
  __typename?: 'RefundPaymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  payment?: Maybe<Payment>;
  success: Scalars['Boolean']['output'];
};

export type Review = {
  __typename?: 'Review';
  club: Club;
  clubId: Scalars['ID']['output'];
  content?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  helpfulCount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  player: Player;
  playerId: Scalars['ID']['output'];
  rating: Scalars['Int']['output'];
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  verified: Scalars['Boolean']['output'];
  visitDate?: Maybe<Scalars['ISO8601Date']['output']>;
};

/** Autogenerated input type of SendTelegramVerificationCode */
export type SendTelegramVerificationCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Phone number in international format */
  phoneNumber: Scalars['String']['input'];
};

/** Autogenerated return type of SendTelegramVerificationCode. */
export type SendTelegramVerificationCodePayload = {
  __typename?: 'SendTelegramVerificationCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  requestId?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type Sport = {
  __typename?: 'Sport';
  active: Scalars['Boolean']['output'];
  bookings: Array<Booking>;
  clubSports: Array<ClubSport>;
  clubs: Array<Club>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  equipment?: Maybe<Scalars['JSON']['output']>;
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  matches: Array<Match>;
  maxPlayers: Scalars['Int']['output'];
  minPlayers: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  popular: Scalars['Boolean']['output'];
  slug: Scalars['String']['output'];
  typicalDuration?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of UnfollowPlayer */
export type UnfollowPlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  followedId: Scalars['ID']['input'];
  followerId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnfollowPlayer. */
export type UnfollowPlayerPayload = {
  __typename?: 'UnfollowPlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UnlikePost */
export type UnlikePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  playerId: Scalars['ID']['input'];
  postId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnlikePost. */
export type UnlikePostPayload = {
  __typename?: 'UnlikePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of UpdateBooking */
export type UpdateBookingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  input: BookingInput;
};

/** Autogenerated return type of UpdateBooking. */
export type UpdateBookingPayload = {
  __typename?: 'UpdateBookingPayload';
  booking?: Maybe<Booking>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateMatch */
export type UpdateMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  input: MatchInput;
};

/** Autogenerated return type of UpdateMatch. */
export type UpdateMatchPayload = {
  __typename?: 'UpdateMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  match?: Maybe<Match>;
};

/** Autogenerated input type of UpdatePlayer */
export type UpdatePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  input: PlayerInput;
};

/** Autogenerated return type of UpdatePlayer. */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  player?: Maybe<Player>;
};

/** Autogenerated input type of UpdatePost */
export type UpdatePostInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  input: PostInput;
};

/** Autogenerated return type of UpdatePost. */
export type UpdatePostPayload = {
  __typename?: 'UpdatePostPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  post?: Maybe<Post>;
};

/** Autogenerated input type of UpdateReview */
export type UpdateReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  rating?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateReview. */
export type UpdateReviewPayload = {
  __typename?: 'UpdateReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  review?: Maybe<Review>;
};

/** Autogenerated input type of VerifyTelegramCode */
export type VerifyTelegramCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Verification code received via Telegram */
  code: Scalars['String']['input'];
  /** Phone number in international format */
  phoneNumber: Scalars['String']['input'];
  /** Optional request ID from send verification */
  requestId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of VerifyTelegramCode. */
export type VerifyTelegramCodePayload = {
  __typename?: 'VerifyTelegramCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  details?: Maybe<Array<Scalars['String']['output']>>;
  error?: Maybe<Scalars['String']['output']>;
  player?: Maybe<Player>;
  success: Scalars['Boolean']['output'];
  token?: Maybe<Scalars['String']['output']>;
};

export type SendTelegramVerificationCodeMutationVariables = Exact<{
  phoneNumber: Scalars['String']['input'];
}>;


export type SendTelegramVerificationCodeMutation = { __typename?: 'Mutation', sendTelegramVerificationCode?: { __typename?: 'SendTelegramVerificationCodePayload', success: boolean, message?: string | null, requestId?: string | null, error?: string | null } | null };

export type VerifyTelegramCodeMutationVariables = Exact<{
  phoneNumber: Scalars['String']['input'];
  code: Scalars['String']['input'];
  requestId?: InputMaybe<Scalars['String']['input']>;
}>;


export type VerifyTelegramCodeMutation = { __typename?: 'Mutation', verifyTelegramCode?: { __typename?: 'VerifyTelegramCodePayload', success: boolean, token?: string | null, error?: string | null, details?: Array<string> | null, player?: { __typename?: 'Player', id: string, name: string, email: string, phone?: string | null, avatarUrl?: string | null, level?: number | null, levelName?: string | null, age?: number | null, address?: string | null, createdAt: any } | null } | null };

export type LoginPlayerMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginPlayerMutation = { __typename?: 'Mutation', loginPlayer?: { __typename?: 'LoginPlayerPayload', token?: string | null, refreshToken?: string | null, errors: Array<string>, player?: { __typename?: 'Player', id: string, name: string, email: string, phone?: string | null, avatarUrl?: string | null, level?: number | null, levelName?: string | null, age?: number | null, address?: string | null, createdAt: any } | null } | null };

export type GetClubsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetClubsQuery = { __typename?: 'Query', clubs: Array<{ __typename?: 'Club', id: string, name: string, city?: string | null, district?: string | null, description?: string | null, imagesUrls: Array<string>, amenities?: any | null, rating?: number | null, reviewCount: number, phone?: string | null, email?: string | null, website?: string | null, workingHours?: any | null, courts: Array<{ __typename?: 'Court', id: string, name: string, surface?: string | null, indoor: boolean }> }> };

export type GetClubQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetClubQuery = { __typename?: 'Query', club?: { __typename?: 'Club', id: string, name: string, city?: string | null, district?: string | null, country?: string | null, postalCode?: string | null, description?: string | null, imagesUrls: Array<string>, amenities?: any | null, phone?: string | null, email?: string | null, rating?: number | null, reviewCount: number, latitude?: number | null, longitude?: number | null, workingHours?: any | null, courts: Array<{ __typename?: 'Court', id: string, name: string, surface?: string | null, indoor: boolean }>, reviews: Array<{ __typename?: 'Review', id: string, rating: number, content?: string | null, createdAt: any, player: { __typename?: 'Player', id: string, name: string, avatarUrl?: string | null } }> } | null };

export type GetDefaultClubQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDefaultClubQuery = { __typename?: 'Query', defaultClub?: { __typename?: 'Club', id: string, name: string, city?: string | null, description?: string | null, imagesUrls: Array<string>, courts: Array<{ __typename?: 'Court', id: string, name: string }> } | null };

export type GetPlayersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPlayersQuery = { __typename?: 'Query', players: Array<{ __typename?: 'Player', id: string, name: string, email: string, phone?: string | null, avatarUrl?: string | null, level?: number | null, levelName?: string | null, createdAt: any }> };

export type GetPlayerQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetPlayerQuery = { __typename?: 'Query', player?: { __typename?: 'Player', id: string, name: string, email: string, phone?: string | null, avatarUrl?: string | null, level?: number | null, levelName?: string | null, age?: number | null, address?: string | null, createdAt: any, updatedAt: any } | null };

export type GetCurrentPlayerQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentPlayerQuery = { __typename?: 'Query', currentPlayer?: { __typename?: 'Player', id: string, name: string, email: string, phone?: string | null, avatarUrl?: string | null, level?: number | null, levelName?: string | null, age?: number | null, address?: string | null, createdAt: any } | null };


export const SendTelegramVerificationCodeDocument = gql`
    mutation SendTelegramVerificationCode($phoneNumber: String!) {
  sendTelegramVerificationCode(input: {phoneNumber: $phoneNumber}) {
    success
    message
    requestId
    error
  }
}
    `;
export type SendTelegramVerificationCodeMutationFn = ApolloReactCommon.MutationFunction<SendTelegramVerificationCodeMutation, SendTelegramVerificationCodeMutationVariables>;

/**
 * __useSendTelegramVerificationCodeMutation__
 *
 * To run a mutation, you first call `useSendTelegramVerificationCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendTelegramVerificationCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendTelegramVerificationCodeMutation, { data, loading, error }] = useSendTelegramVerificationCodeMutation({
 *   variables: {
 *      phoneNumber: // value for 'phoneNumber'
 *   },
 * });
 */
export function useSendTelegramVerificationCodeMutation(baseOptions?: Apollo.MutationHookOptions<SendTelegramVerificationCodeMutation, SendTelegramVerificationCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendTelegramVerificationCodeMutation, SendTelegramVerificationCodeMutationVariables>(SendTelegramVerificationCodeDocument, options);
      }
export type SendTelegramVerificationCodeMutationHookResult = ReturnType<typeof useSendTelegramVerificationCodeMutation>;
export type SendTelegramVerificationCodeMutationResult = ApolloReactCommon.MutationResult<SendTelegramVerificationCodeMutation>;
export type SendTelegramVerificationCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<SendTelegramVerificationCodeMutation, SendTelegramVerificationCodeMutationVariables>;
export const VerifyTelegramCodeDocument = gql`
    mutation VerifyTelegramCode($phoneNumber: String!, $code: String!, $requestId: String) {
  verifyTelegramCode(
    input: {phoneNumber: $phoneNumber, code: $code, requestId: $requestId}
  ) {
    success
    player {
      id
      name
      email
      phone
      avatarUrl
      level
      levelName
      age
      address
      createdAt
    }
    token
    error
    details
  }
}
    `;
export type VerifyTelegramCodeMutationFn = ApolloReactCommon.MutationFunction<VerifyTelegramCodeMutation, VerifyTelegramCodeMutationVariables>;

/**
 * __useVerifyTelegramCodeMutation__
 *
 * To run a mutation, you first call `useVerifyTelegramCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyTelegramCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyTelegramCodeMutation, { data, loading, error }] = useVerifyTelegramCodeMutation({
 *   variables: {
 *      phoneNumber: // value for 'phoneNumber'
 *      code: // value for 'code'
 *      requestId: // value for 'requestId'
 *   },
 * });
 */
export function useVerifyTelegramCodeMutation(baseOptions?: Apollo.MutationHookOptions<VerifyTelegramCodeMutation, VerifyTelegramCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VerifyTelegramCodeMutation, VerifyTelegramCodeMutationVariables>(VerifyTelegramCodeDocument, options);
      }
export type VerifyTelegramCodeMutationHookResult = ReturnType<typeof useVerifyTelegramCodeMutation>;
export type VerifyTelegramCodeMutationResult = ApolloReactCommon.MutationResult<VerifyTelegramCodeMutation>;
export type VerifyTelegramCodeMutationOptions = ApolloReactCommon.BaseMutationOptions<VerifyTelegramCodeMutation, VerifyTelegramCodeMutationVariables>;
export const LoginPlayerDocument = gql`
    mutation LoginPlayer($email: String!, $password: String!) {
  loginPlayer(input: {email: $email, password: $password}) {
    player {
      id
      name
      email
      phone
      avatarUrl
      level
      levelName
      age
      address
      createdAt
    }
    token
    refreshToken
    errors
  }
}
    `;
export type LoginPlayerMutationFn = ApolloReactCommon.MutationFunction<LoginPlayerMutation, LoginPlayerMutationVariables>;

/**
 * __useLoginPlayerMutation__
 *
 * To run a mutation, you first call `useLoginPlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginPlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginPlayerMutation, { data, loading, error }] = useLoginPlayerMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginPlayerMutation(baseOptions?: Apollo.MutationHookOptions<LoginPlayerMutation, LoginPlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginPlayerMutation, LoginPlayerMutationVariables>(LoginPlayerDocument, options);
      }
export type LoginPlayerMutationHookResult = ReturnType<typeof useLoginPlayerMutation>;
export type LoginPlayerMutationResult = ApolloReactCommon.MutationResult<LoginPlayerMutation>;
export type LoginPlayerMutationOptions = ApolloReactCommon.BaseMutationOptions<LoginPlayerMutation, LoginPlayerMutationVariables>;
export const GetClubsDocument = gql`
    query GetClubs {
  clubs {
    id
    name
    city
    district
    description
    imagesUrls
    amenities
    rating
    reviewCount
    phone
    email
    website
    courts {
      id
      name
      surface
      indoor
    }
    workingHours
  }
}
    `;

/**
 * __useGetClubsQuery__
 *
 * To run a query within a React component, call `useGetClubsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetClubsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetClubsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetClubsQuery(baseOptions?: Apollo.QueryHookOptions<GetClubsQuery, GetClubsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetClubsQuery, GetClubsQueryVariables>(GetClubsDocument, options);
      }
export function useGetClubsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetClubsQuery, GetClubsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetClubsQuery, GetClubsQueryVariables>(GetClubsDocument, options);
        }
export function useGetClubsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetClubsQuery, GetClubsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetClubsQuery, GetClubsQueryVariables>(GetClubsDocument, options);
        }
export type GetClubsQueryHookResult = ReturnType<typeof useGetClubsQuery>;
export type GetClubsLazyQueryHookResult = ReturnType<typeof useGetClubsLazyQuery>;
export type GetClubsSuspenseQueryHookResult = ReturnType<typeof useGetClubsSuspenseQuery>;
export type GetClubsQueryResult = ApolloReactCommon.QueryResult<GetClubsQuery, GetClubsQueryVariables>;
export const GetClubDocument = gql`
    query GetClub($id: ID!) {
  club(id: $id) {
    id
    name
    city
    district
    country
    postalCode
    description
    imagesUrls
    amenities
    phone
    email
    rating
    reviewCount
    latitude
    longitude
    courts {
      id
      name
      surface
      indoor
    }
    workingHours
    reviews {
      id
      rating
      content
      player {
        id
        name
        avatarUrl
      }
      createdAt
    }
  }
}
    `;

/**
 * __useGetClubQuery__
 *
 * To run a query within a React component, call `useGetClubQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetClubQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetClubQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetClubQuery(baseOptions: Apollo.QueryHookOptions<GetClubQuery, GetClubQueryVariables> & ({ variables: GetClubQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetClubQuery, GetClubQueryVariables>(GetClubDocument, options);
      }
export function useGetClubLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetClubQuery, GetClubQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetClubQuery, GetClubQueryVariables>(GetClubDocument, options);
        }
export function useGetClubSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetClubQuery, GetClubQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetClubQuery, GetClubQueryVariables>(GetClubDocument, options);
        }
export type GetClubQueryHookResult = ReturnType<typeof useGetClubQuery>;
export type GetClubLazyQueryHookResult = ReturnType<typeof useGetClubLazyQuery>;
export type GetClubSuspenseQueryHookResult = ReturnType<typeof useGetClubSuspenseQuery>;
export type GetClubQueryResult = ApolloReactCommon.QueryResult<GetClubQuery, GetClubQueryVariables>;
export const GetDefaultClubDocument = gql`
    query GetDefaultClub {
  defaultClub {
    id
    name
    city
    description
    imagesUrls
    courts {
      id
      name
    }
  }
}
    `;

/**
 * __useGetDefaultClubQuery__
 *
 * To run a query within a React component, call `useGetDefaultClubQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDefaultClubQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDefaultClubQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetDefaultClubQuery(baseOptions?: Apollo.QueryHookOptions<GetDefaultClubQuery, GetDefaultClubQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDefaultClubQuery, GetDefaultClubQueryVariables>(GetDefaultClubDocument, options);
      }
export function useGetDefaultClubLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDefaultClubQuery, GetDefaultClubQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDefaultClubQuery, GetDefaultClubQueryVariables>(GetDefaultClubDocument, options);
        }
export function useGetDefaultClubSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDefaultClubQuery, GetDefaultClubQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDefaultClubQuery, GetDefaultClubQueryVariables>(GetDefaultClubDocument, options);
        }
export type GetDefaultClubQueryHookResult = ReturnType<typeof useGetDefaultClubQuery>;
export type GetDefaultClubLazyQueryHookResult = ReturnType<typeof useGetDefaultClubLazyQuery>;
export type GetDefaultClubSuspenseQueryHookResult = ReturnType<typeof useGetDefaultClubSuspenseQuery>;
export type GetDefaultClubQueryResult = ApolloReactCommon.QueryResult<GetDefaultClubQuery, GetDefaultClubQueryVariables>;
export const GetPlayersDocument = gql`
    query GetPlayers {
  players {
    id
    name
    email
    phone
    avatarUrl
    level
    levelName
    createdAt
  }
}
    `;

/**
 * __useGetPlayersQuery__
 *
 * To run a query within a React component, call `useGetPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPlayersQuery(baseOptions?: Apollo.QueryHookOptions<GetPlayersQuery, GetPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlayersQuery, GetPlayersQueryVariables>(GetPlayersDocument, options);
      }
export function useGetPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayersQuery, GetPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlayersQuery, GetPlayersQueryVariables>(GetPlayersDocument, options);
        }
export function useGetPlayersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlayersQuery, GetPlayersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlayersQuery, GetPlayersQueryVariables>(GetPlayersDocument, options);
        }
export type GetPlayersQueryHookResult = ReturnType<typeof useGetPlayersQuery>;
export type GetPlayersLazyQueryHookResult = ReturnType<typeof useGetPlayersLazyQuery>;
export type GetPlayersSuspenseQueryHookResult = ReturnType<typeof useGetPlayersSuspenseQuery>;
export type GetPlayersQueryResult = ApolloReactCommon.QueryResult<GetPlayersQuery, GetPlayersQueryVariables>;
export const GetPlayerDocument = gql`
    query GetPlayer($id: ID!) {
  player(id: $id) {
    id
    name
    email
    phone
    avatarUrl
    level
    levelName
    age
    address
    createdAt
    updatedAt
  }
}
    `;

/**
 * __useGetPlayerQuery__
 *
 * To run a query within a React component, call `useGetPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPlayerQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerQuery, GetPlayerQueryVariables> & ({ variables: GetPlayerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlayerQuery, GetPlayerQueryVariables>(GetPlayerDocument, options);
      }
export function useGetPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerQuery, GetPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlayerQuery, GetPlayerQueryVariables>(GetPlayerDocument, options);
        }
export function useGetPlayerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPlayerQuery, GetPlayerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlayerQuery, GetPlayerQueryVariables>(GetPlayerDocument, options);
        }
export type GetPlayerQueryHookResult = ReturnType<typeof useGetPlayerQuery>;
export type GetPlayerLazyQueryHookResult = ReturnType<typeof useGetPlayerLazyQuery>;
export type GetPlayerSuspenseQueryHookResult = ReturnType<typeof useGetPlayerSuspenseQuery>;
export type GetPlayerQueryResult = ApolloReactCommon.QueryResult<GetPlayerQuery, GetPlayerQueryVariables>;
export const GetCurrentPlayerDocument = gql`
    query GetCurrentPlayer {
  currentPlayer {
    id
    name
    email
    phone
    avatarUrl
    level
    levelName
    age
    address
    createdAt
  }
}
    `;

/**
 * __useGetCurrentPlayerQuery__
 *
 * To run a query within a React component, call `useGetCurrentPlayerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentPlayerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentPlayerQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentPlayerQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>(GetCurrentPlayerDocument, options);
      }
export function useGetCurrentPlayerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>(GetCurrentPlayerDocument, options);
        }
export function useGetCurrentPlayerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>(GetCurrentPlayerDocument, options);
        }
export type GetCurrentPlayerQueryHookResult = ReturnType<typeof useGetCurrentPlayerQuery>;
export type GetCurrentPlayerLazyQueryHookResult = ReturnType<typeof useGetCurrentPlayerLazyQuery>;
export type GetCurrentPlayerSuspenseQueryHookResult = ReturnType<typeof useGetCurrentPlayerSuspenseQuery>;
export type GetCurrentPlayerQueryResult = ApolloReactCommon.QueryResult<GetCurrentPlayerQuery, GetCurrentPlayerQueryVariables>;